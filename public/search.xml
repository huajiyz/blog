<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【LOJ10155】数字转换 解题报告</title>
      <link href="/posts/LOJ-10155/"/>
      <url>/posts/LOJ-10155/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>一道非常有意思的树形DP题目，模型转换非常牛逼。</strong></p><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个数 $x$ 的约数（不包括他本身）的和 $y$ 比他本身小，<strong>那么 $x$ 可以变成 $y$，$y$ 也可以变成 $x$</strong>。例如 $4$ 可以变为 $3$，$3$ 可以变为 $4$。限定所有数字变换在不超过 $n$ 的正整数范围内进行，求不断进行数字变换且不出现重复数字的<strong>最多</strong>变换步数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 $n$。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出不断进行数字变换且不出现重复数字的最多变换步数。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p><strong>样例输入</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure></div><p><strong>样例输出</strong></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="PLAIN"><figure class="iseeu highlight /plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></div><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>对于 $100%$ 的数据，$1 \leq n \leq 50000$。</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>规定 $x$ 的约数和（不包括 $x$ 本身*）为 $y$，求 $x$ 和 $y$ 相互变化的最多次数（$1 \leq x,y \leq n$ 且 $x, y$ 均不重复）。</p><p>*：下文中所有约数和均指不包括其本身的约数和。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="优雅暴力"><a href="#优雅暴力" class="headerlink" title="优雅暴力"></a>优雅暴力</h2><p><strong>预处理出 $[1,n]$ 中每一个数的约数和，再进行 $DFS$ 暴力枚举每一个点为根。</strong></p><p>时间复杂度：$O(N^2)$。</p><p><del><em>理论上可以AC，你把评测机CPU往10G上超，超10G，再写个多线程，100ms卡进，要点：一定要超10G，人类感谢你</em></del></p><p>预计得分：$0$</p><h2 id="打表过省一"><a href="#打表过省一" class="headerlink" title="打表过省一"></a>打表过省一</h2><p>将上面的代码放入打表机中打表，后将答案提交到OJ上。</p><p>期望打表时间：100000秒（27小时）</p><p>明显来不及。但我们可以写一个多线程，将处理器的每个线程都利用起来。</p><p>多线程（16线程）打表时间：6250秒（1.7小时）</p><p>预计得分：$100$。</p><h2 id="DFS贪心求法-树上最长链"><a href="#DFS贪心求法-树上最长链" class="headerlink" title="DFS贪心求法 树上最长链"></a>DFS贪心求法 树上最长链</h2><p>显然你懒得写多线程。万物皆可贪。思考一下贪心？</p><p>先预处理出 $[1,n]$ 中每一个数（记作 $x$）的约数和 $y$。然后将 $x$ 与 $y$ 连接。以样例为例，画出来的是一棵<strong>树</strong>！如下图：</p><p><img src="https://s1.ax1x.com/2020/04/14/JSkeRP.md.png" alt="树"></p><p>观察这棵树：</p><p>$4$ 的约数和是 $1+2=3$，将 $4$ 和 $3$ 连接；</p><p>$3$ 的约数和是 $1$，将 $3$ 和 $1$ 连接；</p><p>$7,2,5$ 的约数和都是 $1$，将 $7,2,5$ 分别和 $1$ 连接</p><p>妙啊！！！</p><p>这不就是一个<strong>树上最长链</strong>的问题吗？？？</p><p>树上最长链：<strong>指树上距离最远的两点间的距离，又称树的直径(diameter)</strong>。</p><p>那么，我们怎么求出树上最长链呢？我们先来考虑一下搜索求法。</p><p><strong>解法：</strong></p><ol><li><strong>任选一点 $w$ 为起点，对树进行搜索，找出离 $w$ 最远的点 $u$。</strong></li><li><strong>以 $u$ 为起点，再进行搜索，找出离 $u$ 最远的点 $v$。则 $u$ 到 $v$ 的路径长度即为树的直径。</strong></li></ol><p><strong>证明：</strong>（以下证明太过硬核，本蒟蒻证不出来，摘自<a href="https://zhuanlan.zhihu.com/p/44279763" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44279763</a>）</p><p><strong>如果 $w$ 在直径上，那么 $u$ 一定是直径的一个端点。反证：若 $u$ 不是端点，则从直径另一端点到 $w$ 再到 $u$ 的距离比直径更长，与假设矛盾。</strong></p><p><strong>如果 $w$ 不在直径上，且 $w$ 到其距最远点 $u$ 的路径与直径一定有一交点 $c$ ，当走到点 $c$ 时，由上一个证明可知，接下来离 $c$ 最远的点一定是直径某个端点，所以 $u$ 是直径的一个端点。</strong></p><p><strong>如果 $w$ 不在直径上，且 $w$ 到最远点 $u$ 的路径与直径没有交点，设直径的两端为 $S$ 与 $T$，那么 $(w \to u)&gt;(w \to c)+(c \to T)$，推出 $(w \to u)+(S \to c)+(w \to c)&gt;(S \to c)+(c \to T)=(S \to T) $与假设矛盾。</strong></p><p><strong>因此 $w$ 到最远点 $u$ 的路径与直径必有交点。</strong></p><p>代码片段：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> st)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt; ans) &#123;</span><br><span class="line">        maxu = u;</span><br><span class="line">        ans = st;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].next) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u, st + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Some Code...</span></span><br><span class="line">    <span class="comment">// 调用</span></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    dfs(maxu, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// Some Code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>期望得分：$100$</p><h2 id="树形DP-树上最长链"><a href="#树形DP-树上最长链" class="headerlink" title="树形DP 树上最长链"></a>树形DP 树上最长链</h2><p>设 $f[i]$ 表示以 $i$ 为根，到其子树的叶节点的最大距离。</p><p>转移：$f[u]=max(f[v]+dis(u,v))$。（$dis(u,v)$ 表示 $u \to v$ 的距离，$u$ 为当前节点，$v$ 为 $u$ 的儿子）</p><p>答案：$ans = max(ans, f[v] + f[u] + dis(u, v))$</p><p>代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; ~i; i = e[i].nx) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">        <span class="keyword">if</span> (v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v, u);</span><br><span class="line">        ans = max(ans, f[u] + f[v] + e[i].w);</span><br><span class="line">        f[u] = max(f[u], f[v] + e[i].w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>在实际操作中，我们可以压掉 $f$ 数组，直接通过 $DFS$ 的形式进行 $DP$。（详见代码部分）</p><p>期望得分：$100$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nxt[MAXN], h[MAXN], w[MAXN], e[MAXN], sum[MAXN], sel[MAXN];</span><br><span class="line"><span class="keyword">int</span> edge_num, cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sel[i] = <span class="number">1</span>;</span><br><span class="line">    e[edge_num] = i;</span><br><span class="line">    w[edge_num] = x;</span><br><span class="line">    nxt[edge_num] = h[s];</span><br><span class="line">    h[s] = edge_num++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[u]; i != <span class="number">-1</span>; i = nxt[i])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">int</span> d = dfs(j, u) + w[i];</span><br><span class="line">        <span class="keyword">if</span> (d &gt;= x) y = x, x = d;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (d &gt;= y) y = d;</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = max(cnt, x + y);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n / i; j++)</span><br><span class="line">            sum[i * j] += i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (i &gt; sum[i])</span><br><span class="line">            add_edge(sum[i], i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!sel[i]) </span><br><span class="line">            dfs(i, <span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>期望得分：$100$</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>虽然这是一道及其毒瘤的题目。但是我们在思考时要努力做到一体多解。如果在考场上死活想不出树形DP，可以打表。</p><p>文中讲的两个求最长链的办法，非常套路，需要牢记。</p><p>没了。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 找规律 </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 模型转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1352】没有上司的舞会 解题报告</title>
      <link href="/posts/Luogu-P1352/"/>
      <url>/posts/Luogu-P1352/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><p>详见 <a href="https://www.luogu.com.cn/problem/P1352" target="_blank" rel="noopener">洛谷P1352</a>。</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>题意很简单，就是一个点<strong>被选中后</strong>，其<strong>儿子</strong>就<strong>不能被选</strong>。求选<strong>任意个点</strong>的<strong>最大权值</strong>。（如下图）</p><p><img src="https://s1.ax1x.com/2020/04/10/GTlsG8.png" alt="GTlsG8.png"></p><h1 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h1><p>在开始之前，我们要先了解一下何为<strong>树形DP</strong>。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>树形DP，顾名思义就是 <strong>在树上进行的DP</strong>。由于树固有的<strong>递归性质</strong>，树形 DP 一般都是递归进行的。——OI Wiki.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>树形DP的主要实现形式是 DFS，<strong>在 DFS 中进行 DP</strong>（这不同于一般DP，因为树有递归性质）。</p><p>主要的形式是 $dp[i][j][0\ or\ 1]$。这里，$i$ 是以 $i$ 为根的子树，$j$ 表示在以 $i$ 为根的子树中选择 $j$ 个节点，$0$ 表示这个节点不选，$1$ 表示这个节点选。（当然，实际应用中可能不同于此）</p><h2 id="基本的方程"><a href="#基本的方程" class="headerlink" title="基本的方程"></a>基本的方程</h2><p><strong>选择节点类</strong></p><p>$$<br>\Large<br>\begin{cases}<br>dp[i][0]&amp;=dp[j][1] \\<br>dp[i][1]&amp;=max\ /\ min(dp[j][0],dp[j][1])<br>\end{cases}<br>$$</p><p><strong>树形背包类</strong></p><p>$$<br>\Large<br>\begin{cases}<br>dp[v][k]&amp;=dp[u][k]+val \\<br>dp[u][k]&amp;=max(dp[u][k],dp[v][k−1])<br>\end{cases}<br>$$</p><h1 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h1><h2 id="暴力出奇迹"><a href="#暴力出奇迹" class="headerlink" title="暴力出奇迹"></a>暴力出奇迹</h2><p>很简单，枚举每个点选或不选，最后再统计一遍是否可行并记录 $answer$。</p><p>时间复杂度：$O(2^{N} \times N)$</p><p>然后你高兴的发现 BOOM 了。</p><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>我们可以令 $dp[i][0\ or\ 1]$ 为以 $i$ 为根的子树的最优解（第二维 $0$ 表示 $i$ 不参加舞会，$1$ 表示参加舞会）</p><p>则我们推出状态转移方程（$son$ 是 $x$ 的儿子）</p><p>$$<br>\Large<br>\begin{cases}<br>dp[i][0] &amp;= \sum max(dp[son][0], dp[son][1]) \ \normalsize (当前点不选，儿子可以参加也可以不参加) \\<br>dp[i][1] &amp;= \sum dp[son][0] + a_i \ \normalsize (当前点选，儿子没得参加)<br>\end{cases}<br>$$</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> MAXN 10005</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> r[MAXN], v[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; son[MAXN];  <span class="comment">// vector方便操作</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[x][<span class="number">1</span>] = r[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; son[x].size(); i++) <span class="comment">// 循环遍历儿子</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> y = son[x][i];    <span class="comment">// i号儿子</span></span><br><span class="line">        dfs(y);        <span class="comment">// 先dfs</span></span><br><span class="line">        f[x][<span class="number">0</span>] += max(f[y][<span class="number">0</span>], f[y][<span class="number">1</span>]);  <span class="comment">// dp</span></span><br><span class="line">        f[x][<span class="number">1</span>] += f[y][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;r[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        son[y].push_back(x);    <span class="comment">// 构建树</span></span><br><span class="line">        v[x] = <span class="number">1</span>;    <span class="comment">// 打个标记，方便找根</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (!v[i])   <span class="comment">// 如果没被标记，i就是根</span></span><br><span class="line">        &#123;</span><br><span class="line">            root = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    dfs(root);   <span class="comment">// dfs</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, max(f[root][<span class="number">0</span>], f[root][<span class="number">1</span>]));   <span class="comment">// 答案即为max(根选,根不选)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>一道裸的树形DP。<del>没啥总结</del> 总结好像写在前置知识里了。还有，本题样例特别坑，权值全是1，模拟/验证的时候尽量自己再造一组。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P2704】【NOI2001】炮兵阵地 解题报告</title>
      <link href="/posts/Luogu-P2704/"/>
      <url>/posts/Luogu-P2704/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h1 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>司令部的将军们打算在 $N \times M$ 的网格地图上部署他们的炮兵部队。一个 $N \times M$ 的地图由 $N$ 行 $M$ 列组成，地图的每一格可能是山地（用 <code>H</code> 表示），也可能是平原（用 <code>P</code> 表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p><p><img src="http://media.openjudge.cn/images/1185_1.jpg" alt></p><p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。 现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>第一行包含两个由空格分割开的正整数，分别表示 $N$ 和 $M$ ；</p><p>接下来的 $N$ 行，每一行含有连续的 $M$ 个字符（<code>P</code> 或者 <code>H</code>），中间没有空格。按顺序表示地图中每一行的数据。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>仅一行，包含一个整数$K$，表示最多能摆放的炮兵部队的数量。</p><h2 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h2><p>样例输入</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">4</span></span><br><span class="line">PHPP</span><br><span class="line">PPHH</span><br><span class="line">PPPP</span><br><span class="line">PHPP</span><br><span class="line">PHHP</span><br></pre></td></tr></table></figure></div><p>样例输出</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="ANGELSCRIPT"><figure class="iseeu highlight /angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></div><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$100%$ 的数据，$N \leq 100；M \leq 10$</p><h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>题意很简单，即下图中的黑色十字架上不能放两个或以上的炮兵，不然会自己人打自己人<del>内讧</del>。然后只能在平地放炮兵。</p><p><img src="http://media.openjudge.cn/images/1185_1.jpg" alt></p><p>问你最多能放多少个炮兵。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><h2 id="暴力出奇迹"><a href="#暴力出奇迹" class="headerlink" title="暴力出奇迹"></a>暴力出奇迹</h2><p>怎么暴力？DFS枚举每个点放不放炮兵，最后统计一遍是否成立。</p><p>时间复杂度 $O(2^{nm} \times nm)$</p><p>$\Large \textbf {BOOM!}$</p><h2 id="正解——状压DP"><a href="#正解——状压DP" class="headerlink" title="正解——状压DP"></a>正解——状压DP</h2><p>因为 $M \leq 10$，所以把<strong>每一行部署炮兵的状态</strong>作为状态，可以二进制压缩至 <code>int</code> 内。</p><p>因为 DP <strong>从上到下转移</strong>，考虑第 $i$ 行时，要考虑第 $i-1，i-2$ 行，考虑第 $i-1$ 行时，又要考虑 $i-2, i-3$ 行。</p><p><strong>所以令 $f[i][j][k]$ 表示前 $i$ 行，第 $i$ 行状态为 $j$，第 $i-1$ 行状态为 $k$ 时可以部署炮兵部队的最大值。</strong></p><p><strong>初始化：</strong> $f[0][0][0] = 0,$ 其他为 <code>INT_MIN</code></p><p><strong>转移：$f[i][j][k] = max(f[i-1][k][p] + cnt[j]) \ (j, k, p \textbf {是合法的})$</strong></p><p>同时 $j \ and \ k = 0, \ j \ and \ l = 0, \ j \ and \ map[i] = 0$</p><p>时间复杂度 $O(n * S^3) \ (S为一行内合法的状态总数)$。显然，这里 $S \leq m$，则时间应该为十万级别，可以 $AC$。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> n, m, tot;</span><br><span class="line"><span class="keyword">int</span> s[<span class="number">128</span>], cnt[<span class="number">128</span>], <span class="built_in">map</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">128</span>][<span class="number">72</span>][<span class="number">72</span>];</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">32</span>];</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">input</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[i] &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (str[j] == <span class="string">'H'</span>)</span><br><span class="line">                <span class="built_in">map</span>[i] |= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcount</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) x -= x &amp; -x, ++sum;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span>&lt;&lt;m); i++)</span><br><span class="line">        <span class="keyword">if</span> (!(i &amp; (i&lt;&lt;<span class="number">1</span>)) &amp;&amp; !(i &amp; (i&lt;&lt;<span class="number">2</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            s[++tot] = i;</span><br><span class="line">            cnt[tot] = getcount(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">207</span>, <span class="keyword">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= tot; k++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= tot; p++)</span><br><span class="line">                    <span class="keyword">if</span> ((s[j] &amp; s[k]) == <span class="number">0</span> &amp;&amp; (s[j] &amp; s[p]) == <span class="number">0</span> &amp;&amp; (s[j] &amp; <span class="built_in">map</span>[i]) == <span class="number">0</span>)</span><br><span class="line">                        f[i][j][k] = <span class="built_in">std</span>::max(f[i<span class="number">-1</span>][k][p] + cnt[j], f[i][j][k]);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot; j++)</span><br><span class="line">            ans = <span class="built_in">std</span>::max(f[n][i][j], ans);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    input();</span><br><span class="line">    init();</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>此题是状态压缩毒(<del>mu</del>)瘤(<del>ban</del>)题，在这种 $n$ 或 $m$ 较小的情况下，可以压缩较小的那一个。另外，对于这种依赖于前面结果的 DP，可以把前一个结果加入状态，方便转移。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状态压缩 </tag>
            
            <tag> DP </tag>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客恢复更新</title>
      <link href="/posts/hello-world/"/>
      <url>/posts/hello-world/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p>博客域名已更换至 <code>baoyh.cf</code>！原 <code>baoyh.ml</code> 不保证可用！请大家收藏新网址！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 通知 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【NOI Online 入门组】文具订购 解题报告</title>
      <link href="/posts/NOI-Online-WJDG/"/>
      <url>/posts/NOI-Online-WJDG/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>$\text{满足以下条件}$</p><p>$\text{1、}7a+4b+3c=n.$</p><p>$\text{2、在满足条件1的情况下，}\ min(a,b,c)\ \text{尽可能大}.$</p><p>$\text{3、在满足条件1、2的情况下，}\ a+b+c\ \text{尽可能大}.$</p><p>$\text{求满足条件的最优方案} \ {a,b,c} \ \text{（保证最优解唯一，若不满足，输出-1）} $</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>题目要求先满足条件 $1$，但是我们并不能在 $O(1)$ 的时间内快速求出满足条件的 $a,b,c$，所以我们可以先做条件 $2.$ 满足条件 $2$ 很简单，我们可以视作 $1a, 1b, 1c$ 为一组，从最多的组数 $n/14$ 开始向下枚举即可$.$ 最后我们把分组后剩下的再进行枚举，并求出合法的最优解即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @Author: 蒟蒻 BYH </span></span><br><span class="line"><span class="comment"> * @Date: 2020-03-07 14:44:48 </span></span><br><span class="line"><span class="comment"> * @Last Modified by: 蒟蒻 BYH</span></span><br><span class="line"><span class="comment"> * @Last Modified time: 2020-03-07 20:01:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    freopen(<span class="string">"order.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"order.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">int</span> num = n / <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">-1</span>;       <span class="comment">//存储当前最多的物品数量</span></span><br><span class="line">    <span class="keyword">int</span> ans[<span class="number">8</span>] = &#123;<span class="number">0</span>&#125;;   <span class="comment">//存储答案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = num; i &gt;= <span class="number">0</span>; i--)   <span class="comment">//尽可能先保证买多组物品，优先满足条件2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = n - i * <span class="number">14</span>;   <span class="comment">//剩下的钱</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;    <span class="comment">//是否有解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j1 = <span class="number">0</span>; j1 &lt;= s / <span class="number">3</span>; j1++)    <span class="comment">//先买最便宜的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j2 = <span class="number">0</span>; j2 &lt;= s / <span class="number">4</span>; j2++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j3 = <span class="number">0</span>; j3 &lt;= s / <span class="number">7</span>; j3++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j1 * <span class="number">3</span> + j2 * <span class="number">4</span> + j3 * <span class="number">7</span> != s) <span class="keyword">continue</span>;  <span class="comment">//不满足条件1</span></span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (j1 + j2 + j3 + i*<span class="number">3</span> &gt; Max)  <span class="comment">//记录更优的</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Max = j1 + j2 + j3 + i*<span class="number">3</span>;</span><br><span class="line">                        ans[<span class="number">0</span>] = j1 + i;</span><br><span class="line">                        ans[<span class="number">1</span>] = j2 + i;</span><br><span class="line">                        ans[<span class="number">2</span>] = j3 + i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, ans[<span class="number">2</span>], ans[<span class="number">1</span>], ans[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);  <span class="comment">//不满足任何条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> NOI Online </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1774】最接近神的人 解题报告</title>
      <link href="/posts/Luogu-P1774/"/>
      <url>/posts/Luogu-P1774/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h2 id="前置芝士"><a href="#前置芝士" class="headerlink" title="前置芝士"></a>前置芝士</h2><p><strong>逆序对</strong></p><p>首先我们要知道逆序对是什么。在一个序列 ${a}$ 中，如果 $a_i &gt; a_j $ 且 $i&lt;j$，那么就说 $a_i$ 和 $a_j$ 是一对 <strong>逆序对</strong>。</p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>用 <strong>最少</strong> 的交换次数使原序列变成不下降序列（升序）。如果 $a_i &gt; a_j$ 且 $i &lt; j$，那么我们一定要 <strong>交换</strong> 这两个数，否则的话无法满足升序的要求。显然这是在让我们求逆序对个数。交换 ${a}$ 中的所有逆序对，也就满足了序列有序的要求。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>$\href{<a href="https://www.luogu.com.cn/problem/P1908}" target="_blank" rel="noopener">https://www.luogu.com.cn/problem/P1908}</a> {Problem \ \textit{1908} }$ 此题贵在将题意进行转换，最终变成了一个板子。如果你不会实现求逆序对的个数，可以到 $P1908$ 中翻看已有题解，此题解不重复造轮子。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], answer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> tmp[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &lt; e) &#123;</span><br><span class="line"><span class="keyword">int</span> m = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">mergeSort(a, s, m, tmp);</span><br><span class="line">mergeSort(a, m + <span class="number">1</span>, e, tmp);</span><br><span class="line"><span class="keyword">int</span> pb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> p1 = s, p2 = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= e) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[p1] &lt;= a[p2]) tmp[pb++] = a[p1++];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp[pb++] = a[p2++];</span><br><span class="line">answer += m - p1 + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= m) tmp[pb++] = a[p1++];</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= e) tmp[pb++] = a[p2++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e - s + <span class="number">1</span>; i++)</span><br><span class="line">a[s + i] = tmp[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">mergeSort(a, <span class="number">1</span>, n, b);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; answer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 逆序对 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P6013】CSGRound3 压岁钱</title>
      <link href="/posts/Luogu-P6013/"/>
      <url>/posts/Luogu-P6013/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p><strong>纯模拟，暴力 $O(n)$ 可过。</strong></p><p>其实这道题目主要是让你处理 $\color{red} case\ 3$ 的情况。其实很简单，题目的事件编号是固定的递增序列 ${1,2,3,4,5,6…}$。那么就可以用一个数组 $que[i]$ 来表示第 $i$ 件事件有多少钱被<strong>解除</strong>封印。</p><p>然后写出了第一个代码：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> que[<span class="number">1000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, flag, a, b, t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> money = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (que[i]) money = money + que[i];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;flag);</span><br><span class="line"><span class="keyword">switch</span> (flag) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line">money = money + a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (a &gt; money) answer++;</span><br><span class="line"><span class="keyword">else</span> money = money - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line">que[b] = a;</span><br><span class="line">money = money - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, answer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>$Rid:29783489. \color{red} \ 50pt/592ms/4.38MB$</p><p>怎么 50 分？<strong>题目不保证</strong> $\textit{b}$ <strong>总是不相同</strong>！然后仔细地看了一下：</p><p><del>$\sout{OI}$十年一场空，不开 $\sout {long \ long}$ 见祖宗</del></p><p>代码二：</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll; <span class="comment">//懒得改 long long. qwq</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll        <span class="comment">//define 大法好！</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> que[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, flag, a, b;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> money = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (que[i]) money = money + que[i];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;flag);</span><br><span class="line"><span class="keyword">switch</span> (flag) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a);</span><br><span class="line">money = money + a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;a);</span><br><span class="line"><span class="keyword">if</span> (a &gt; money) answer++;</span><br><span class="line"><span class="keyword">else</span> money = money - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;a, &amp;b);</span><br><span class="line">que[b] += a; <span class="comment">//important!</span></span><br><span class="line">money = money - a;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, answer);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>ps. 此代码非常取$\sout{(lan)}$巧$\sout{(duo)}$地用了 define 来便携的将全局的所有 $int,\ signed \ int,\ unsigned \ int$ 都相应改为了 $long\ long,\ signed \ long \ long,\ unsigned \ long \ long$。</p><p>春节快乐鸭！</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1833】樱花 解题报告</title>
      <link href="/posts/Luogu-P1833/"/>
      <url>/posts/Luogu-P1833/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20180224/08196272d5454c1fb85e84f0b4fd44ca.jpeg" alt></p><p><strong>创新之处</strong></p><ol><li><p>背包的处理用模块化，封装成几个函数，可以当成模板使用</p></li><li><p>输入时，时间的处理用了数学方法，无需写繁琐的$if$</p></li><li><p>本题解介绍了一下多重背包 $O(V<em>Σlog n[i])$ 的推导过程，弱化成了生活中常见的 *</em>称砝码问题**。</p></li></ol><h2 id="弱化"><a href="#弱化" class="headerlink" title="弱化"></a>弱化</h2><p>首先我们先考虑一下 <strong>01背包</strong> 和 <strong>完全背包</strong> 的混合。</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N</span><br><span class="line">    <span class="keyword">if</span> 第i件物品属于<span class="number">01</span>背包</span><br><span class="line">        <span class="keyword">for</span> v=V.<span class="number">.0</span></span><br><span class="line">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> 第i件物品属于完全背包</span><br><span class="line">        <span class="keyword">for</span> v=<span class="number">0.</span>.V</span><br><span class="line">            f[v]=max&#123;f[v],f[v-c[i]]+w[i]&#125;;</span><br></pre></td></tr></table></figure></div><p>伪代码已给出，应该很容易想到这个代码实现。</p><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><p>一种很好实现的思路就是 转化为 <strong>01背包</strong> 进行求解。对于一组<del>物品</del>樱花树，我们设其观赏时间为 $weight$，观赏美感值为 $cost$，观赏上限为 $amount$，那么我们可以得到一个伪代码</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> j=<span class="number">1.</span>.amount   <span class="comment">//做amount次</span></span><br><span class="line">  ZeroOnePack(weight, cost) <span class="comment">//01背包</span></span><br></pre></td></tr></table></figure></div><p>其时间复杂度为 <em>$O(V*Σn[i])$</em> 。显然在此题中是无法通过满分的。</p><p>我们考虑另外一种思路，就是将其进行 <strong>二进制拆分</strong>。因为任意一个数都能转换成一个二进制数。如果你无法理解，那么可以想象成一个 <strong>称砝码</strong> 的小游戏——</p><blockquote><p>现在有一堆砝码。我们要称重量不超过 $100g$ 的物体。如何用最少的砝码来称出所有重量的物体？</p></blockquote><p>显然我们可以使用 $1,2,4,8,16,32,64……2^k$ 重量的砝码来进行称重，只是注意我们不能 <strong>超量(超量程qaq)</strong> ，也就是说我只想称 $20g$ 的物体，然后你拿着 $1,2,4,8,16$ 的砝码来称，这样意味着最多可以称出 $1+2+4+8+16=31g$ 的物体！<del>超重</del></p><p>这样我们写出了时间复杂度为 $O(V<em>Σlog n[i])$ 的基于 <strong>01背包</strong> 的 <strong>多重背包</strong> 问题。*伪代码如下——</em></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> dp[], <span class="keyword">int</span> weight, <span class="keyword">int</span> cost, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (weight * amount &gt;= v || amount == <span class="number">0</span>) &#123;  <span class="comment">//其实就是一个完全背包，不必要进行拆分，直接 O(n) 做</span></span><br><span class="line">        CompletePack(dp, weight, cost);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= amount; k &lt;&lt;= <span class="number">1</span>) &#123;   <span class="comment">//进行二进制拆分</span></span><br><span class="line">    ZeroOnePack(dp, weight*k, cost*k);  <span class="comment">//做01背包</span></span><br><span class="line">    amount -= k;   <span class="comment">//将物品减去，防止“超重”</span></span><br><span class="line">&#125;</span><br><span class="line">    ZeroOnePack(dp, amount*weight, amount*cost);  <span class="comment">//剩余的“砝码”再做一次</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>希望你理解一下这个代码，不懂的话多模拟几遍。</p><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><p>整合起来就可以 $3$ 种背包进行分类操作。<em>伪代码如下</em></p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.N   </span><br><span class="line">    <span class="keyword">if</span> 第i件物品属于<span class="number">01</span>背包</span><br><span class="line">        ZeroOnePack(....)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> 第i件物品属于完全背包</span><br><span class="line">        CompletePack(.....)</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> 第i件物品属于多重背包</span><br><span class="line">        MultiplePack(.....)</span><br></pre></td></tr></table></figure></div><p>当然如果想偷个懒，直接调用 <code>MultiplePack()</code> 也是可以的。但是需要特判一下输入 $0$ 去做完全背包。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10005</span>]; <span class="keyword">int</span> v;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ZeroOnePack</span><span class="params">(<span class="keyword">int</span> dp[], <span class="keyword">int</span> weight, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = v; j &gt;= weight; j--)</span><br><span class="line">        dp[j] = max(dp[j], dp[j-weight]+cost);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompletePack</span><span class="params">(<span class="keyword">int</span> dp[], <span class="keyword">int</span> weight, <span class="keyword">int</span> cost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = weight; j &lt;= v; j++)</span><br><span class="line">        dp[j] = max(dp[j], dp[j-weight]+cost);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MultiplePack</span><span class="params">(<span class="keyword">int</span> dp[], <span class="keyword">int</span> weight, <span class="keyword">int</span> cost, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (weight * amount &gt;= v || amount == <span class="number">0</span>) &#123;</span><br><span class="line">        CompletePack(dp, weight, cost);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= amount; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    ZeroOnePack(dp, weight*k, cost*k);</span><br><span class="line">    amount -= k;</span><br><span class="line">&#125;</span><br><span class="line">    ZeroOnePack(dp, amount*weight, amount*cost);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> time1, time2, time3, time4, n, w, c, a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d:%d %d:%d %d\n"</span>, &amp;time1, &amp;time2, &amp;time3, &amp;time4, &amp;n);  <span class="comment">//时间的处理，输入用scanf进行格式化输入</span></span><br><span class="line">v = time3*<span class="number">60</span>+time4-time1*<span class="number">60</span>-time2;  <span class="comment">//很暴力地直接算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;w, &amp;c, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="number">0</span>) CompletePack(dp, w, c);</span><br><span class="line">        <span class="keyword">else</span> MultiplePack(dp, w, c, a);</span><br><span class="line"><span class="comment">//        printf("DP on Time [%d]: %d\n", i, dp[v]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, dp[v]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01背包 </tag>
            
            <tag> DP </tag>
            
            <tag> 多重背包 </tag>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1062】数列 解题报告</title>
      <link href="/posts/Luogu-P1062/"/>
      <url>/posts/Luogu-P1062/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p>洛谷 P1062 数列 解题报告。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>请见 <a href="https://www.luogu.com.cn/problem/P1062" target="_blank" rel="noopener">Luogu P1062 数列</a>。</p><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>让你求 $k^0,k^1,k^0+k^1,k^2,k^0+k^2,k^1+k^2,k^0+k^1+k^2$ 这个数列的第$n$项，$k &lt;= 15, n &lt;= 1000$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把这个数列 $(k = 3)$ 转成 <strong>二进制</strong> 看看。</p><p>原始数 $3^0$,$3^1$,$3^0+3^1$,$3^2$<br>二进制 $1$,$10$,$11$,$100$<br>十进制 $1$,$2$,$3$,$4$</p><p>emm <del>真香</del> 发现了一点规律吗？第$n$个数，答案就是$n$转换成二进制后当成$k$进制进行计算的值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k, n, pow2[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;k, &amp;n);</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n) &#123;</span><br><span class="line">pow2[++len] = n % <span class="number">2</span>;</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">ans += <span class="built_in">pow</span>(k, i<span class="number">-1</span>) * pow2[i]; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>$PS:$ 其实题目里已经给提示了，就是让你输出十进制。。。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 找规律 </tag>
            
            <tag> 进制转换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1193】洛谷团队训练VS传统团队训练 解题报告</title>
      <link href="/posts/Luogu-P1193/"/>
      <url>/posts/Luogu-P1193/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p>洛谷 P1193 洛谷团队训练VS传统团队训练 解题报告。<br>文章主要讲述了 C++ Map 在离散化中的基本应用。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>请见 <a href="https://www.luogu.com.cn/problem/P1193" target="_blank" rel="noopener">Luogu P1193 洛谷团队训练VS传统团队训练</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一看到 <del>像抽纸一样长的题面</del> 就知道是大模拟。</p><p>其实只需要攻克 <strong>学号</strong> 和 <strong>题目编号</strong> 两个数据的存储就可以了。可以用 $STL Map$ 映射大法，来进行数据的离散化，带上一个 $log$ 的时间复杂度也是可以接受的。</p><p>那么传统方式，究竟是去教师机评测还是自己测呢？比较两者的总时间取最优即可。</p><p>而洛谷的时间很好算，$O(1)$ 就可以完成。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ta, tb, tc, td, A, H, E, R;</span><br><span class="line"><span class="built_in">map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; problem, student;</span><br><span class="line"><span class="comment">// problem[i] 和 student[i] 进行离散化 </span></span><br><span class="line"><span class="keyword">int</span> score[<span class="number">1005</span>][<span class="number">1005</span>], submit[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="comment">// score 存储得分，submit存储提交记录（已经离散化）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">int</span> t; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">problem[t] = i;   <span class="comment">// map映射problem_id </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;t);</span><br><span class="line">student[t] = i;   <span class="comment">// map映射student_id</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d%d%d%d"</span>, &amp;ta, &amp;tb, &amp;tc, &amp;td, &amp;A, &amp;H, &amp;E, &amp;R);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> luoguTime = n*ta+R*tc, cenaTime = n*ta;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> pi, si, sc;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;pi, &amp;si, &amp;sc);</span><br><span class="line">si = student[si], pi = problem[pi], submit[pi][si]++;</span><br><span class="line"><span class="keyword">if</span> (E &amp;&amp; sc&gt;score[pi][si]) score[pi][si] = sc, cenaTime += td;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">cenaTime += min(tb * submit[i][j], ta + tc*submit[i][j]); </span><br><span class="line">&#125;</span><br><span class="line">luoguTime = (<span class="keyword">long</span> <span class="keyword">long</span>)luoguTime/(A/<span class="number">100.0</span>) + H;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n%lld\n%s\n"</span>, cenaTime, luoguTime, (cenaTime&lt;luoguTime)?(<span class="string">"Forget it..."</span>):(<span class="string">"Use Luogu!"</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Map映射 </tag>
            
            <tag> STL </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1440】 求m区间内的最小值 解题报告</title>
      <link href="/posts/Luogu-P1440/"/>
      <url>/posts/Luogu-P1440/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p>洛谷 P1440 求m区间内的最小值 解题报告。此文主要讲述了单调队列在动态规划中优化的应用。</p><p>emm 蒟蒻最近刚学单调队列，这是一道单调队列的入门题，然后已经有的题解都是直接讲代码，蒟蒻自己来讲一讲<del>通俗易懂</del>的思路吧。（其实代码很短，核心只有5行，各位不必恐慌）</p><h2 id="暴力出奇迹"><a href="#暴力出奇迹" class="headerlink" title="暴力出奇迹"></a>暴力出奇迹</h2><p>这题所有人看到题面的第一个反应，肯定是暴力。每次查找前$m$个数不就行了？一看数据范围，顿时无语。$O(n*m)$暴力完美$TLE$。</p><h2 id="找到优化的契机"><a href="#找到优化的契机" class="headerlink" title="找到优化的契机"></a>找到优化的契机</h2><p>我们观察样例，从中发现了一些规律——在寻找 $i$ 的前 $m$ 个数的时候，发现了重复。<strong>我们在寻找 $i-1$ 的前 $m$ 个数的时候，枚举了区间 $[i-m, i-1]$。而我们在寻找 $i$ 的前 $m$ 个数的时候，又枚举了区间 $[i-m+1, i]$。也就是说，我们重复枚举了 $m-1$ 个数，这些数导致了如此高的时间复杂度。</strong></p><p>如图。</p><p><img src="https://ae01.alicdn.com/kf/H90a9a90e794d494389d8859f69fc737cB.jpg" alt></p><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>我们发现，在求<code>min</code>值的过程中，重复遍历了这个数组，导致效率低下。</p><p>那么，我们能不能记录下<code>min</code>值呢？我们发现，其实我们<strong>要求的区间是固定的</strong>。那么我们思考一下，</p><p><strong>如果， $j$ 在某一个区间里面是最小值，在这时，来了一个 $i$ 。$i$ 比 $j$ 来的小，也比 $j$ 后来（换句话说，$i$ 比 $j$ 年轻，又比 $j$ 优秀），那么 $j$ 永远不可能成为之后区间里面的 $min$ 值了！那么，我们可以不用考虑 $j$，把 $j$ 弹出。</strong></p><p>那么，我们发现，这是一个 <strong>先进先出</strong> 的数据结构，很显然，我们使用 <strong>队列</strong> 来进行操作。</p><p>但是，我们还需要考虑一点：<strong>队列中每一个元素都要比前面来的优秀，所以，我们还需要维护队列的单调性。</strong></p><p>我们就引入了一个新的数据结构：<strong>单调队列 $Monotone-Queue$</strong></p><p>这种数据结构常与 <strong>动态规划</strong> 算法连用，作用于 <strong>状态1D/转移1D 等</strong> 动态规划中。在此题中，<strong>我们在一端维护单调性，另一端维护时效性</strong>。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">2000005</span>], que[<span class="number">2000005</span>];</span><br><span class="line"><span class="comment">// que数组模拟单调队列的操作</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">    <span class="comment">// 一开始，先输出一个0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; a[que[tail]] &gt;= a[i]) tail--;</span><br><span class="line">    <span class="comment">// 维护单调性</span></span><br><span class="line">    que[++tail] = i;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail &amp;&amp; que[head] &lt;= i-m) head++;</span><br><span class="line">    <span class="comment">// 维护时效性</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a[que[head]]);</span><br><span class="line">    <span class="comment">// 最后输出队列的head就可以了</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总而言之，单调队列在OI中的应用很少。但是，这是一个很重要的板子。如果你理解透彻了，就把它记忆下来。很多类型动态规划的优化就是基于这个模板的。</p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
            <tag> DP优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1060】开心的金明 解题报告</title>
      <link href="/posts/Luogu-P1060/"/>
      <url>/posts/Luogu-P1060/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><p>洛谷 P1060 开心的金明 解题报告。<br>此题为 2006年 NOIP 普及 原题。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>请见 <a href="https://www.luogu.com.cn/problem/P1060" target="_blank" rel="noopener">Luogu P1060 开心的金明</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>很明显的背包问题。唯一注意的是要求 <strong>总钱数的物品的价格与重要度乘积的总和的最大值</strong>。那么我们将背包的价值设为 $w[i] * v[i]$ 即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> v[<span class="number">10005</span>], w[<span class="number">10005</span>], f[<span class="number">50005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">"%d%d"</span>, &amp;n, &amp;m );</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>( <span class="string">"%d%d"</span>, &amp;v[i], &amp;w[i] );</span><br><span class="line">w[i] = v[i] * w[i];    <span class="comment">// important </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> j = n; j &gt;= v[i]; j-- ) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= v[i])</span><br><span class="line">f[j] = max(f[j], f[j-v[i]] + w[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[n]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 01背包 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 2006普及 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【洛谷P1387】最大正方形</title>
      <link href="/posts/Luogu-P1387/"/>
      <url>/posts/Luogu-P1387/</url>
      
        <content type="html"><![CDATA[<!-- build time:Wed Apr 15 2020 09:22:39 GMT+0800 (GMT+08:00) --><h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个 $01$ 矩阵，寻找不包含 $0$ (即全为 $1$) 的最大的正方形。 矩阵的长和宽 $&lt;=100$。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>既然这个矩阵只由 $0$ 和 $1$ 组成，那么我们不妨来开一个数组 $s[i][j]$ 表示二维前缀和，这样我们就可以使用 $O(1)$ 的时间来完成 全 $1$ 正方形 的判断。最终只需要枚举起点 $(i,j)$ 和 正方形的大小 $size$ 即可。</p><h2 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h2><p>前缀和，是一种类似于动态规划的思想。一维前缀和大家都不陌生，即用 $s[i]$ 表示 前 $i$ 个数的总和，即可用 $O(1)$ 的时间来算出 $a[i]$ 到 $a[j]$ 的和（$s[j]-s[i-1]$）。</p><p>二维前缀和是在一维前缀和的基础上进行的。我们很容易想到用 $s[i][j]$ 来表示 <strong>前 $i$ 行 $j$ 个数的和</strong>。那么我们也可以算出 $a[i][j]$ 到 $a[x][y]$ 的和 $(x&gt;=i, y &gt;= j)$。即为 $s[x][y]+s[i-1][j-1]-s[i-1][y]-s[x][j-1] $。</p><p>下面这张图可以清晰地表现出二维前缀和的区间计算过程。图引自 <a href="https://blog.csdn.net/qq_34990731/article/details/82807870" target="_blank" rel="noopener">https://blog.csdn.net/qq_34990731/article/details/82807870</a></p><p><img src="https://s2.ax1x.com/2019/12/07/QNsA6s.png" alt="QNsA6s.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>C++$/48ms/820.00KB$</p><div class="highlight-wrap"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>][<span class="number">105</span>], s[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = s[x][y]+s[i<span class="number">-1</span>][j<span class="number">-1</span>]-s[i<span class="number">-1</span>][y]-s[x][j<span class="number">-1</span>];</span><br><span class="line"><span class="comment">//printf("#query (%d,%d)-&gt;(%d,%d) = %d\n", i,j,x,y,res);</span></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i][j]);</span><br><span class="line">s[i][j] = s[i<span class="number">-1</span>][j] + s[i][j<span class="number">-1</span>] - s[i<span class="number">-1</span>][j<span class="number">-1</span>] + a[i][j];  <span class="comment">//前缀和</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123; <span class="comment">//枚举起点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> size = <span class="number">1</span>; size &lt;= min(n-i+<span class="number">1</span>,m-j+<span class="number">1</span>); size++) &#123;<span class="comment">//枚举size，注意边界</span></span><br><span class="line"><span class="keyword">if</span> (query(i,j,i+size<span class="number">-1</span>,j+size<span class="number">-1</span>) == size*size) <span class="comment">//O(1)查询</span></span><br><span class="line">ans = max(ans, size);<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="string">'b'</span>&amp;<span class="string">'y'</span>&amp;<span class="string">'h'</span>&amp;<span class="number">0</span>; <span class="comment">//防伪标识</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p><strong><em>珍爱生命，远离抄袭　Solution By Byh</em></strong></p><!-- rebuild by neat -->]]></content>
      
      
      <categories>
          
          <category> 解题报告 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
